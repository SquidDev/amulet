# Type system
Types in Amulet are composed of functions, tuples and primitives. You can store multiple types together in a tagged union (or sum type). A tagged union with one entry is a useful way of boxing a type to ensure that it cannot be accidentally used as an object of the same type but different semantics.

Types can also be generic over one or more parameters. When inferring the type for an expression, the most generic type will always be used. Constraints can be put on generic parameters by specifying type class implementations that must exist for this set of parameters. There can be multiple constraints, each applying to multiple parameters.

There is no subtyping in Amulet, _however_ type constraints can be loosened through the upcast operator: this converts an existing value to a more general type: for instance `[a]` can be upcast to `Show b`.

## For-All and Exists
> **TODO**

## Record types
Record types are simple syntactic sugar for a product type. By defining a record type you create a product type and a series of methods (labeled fields) to extract a field from the record instance. Methods are also generated to "update" the record with a new value for a particular field.

## Tagged unions
Tagged unions, also known as _sum-of-product types_, are data structures that can take on several variations. Only one of these variants may be in use at once, and a tag field explicitly indicates so.

To extract data out of sum types, pattern matching is used.

Tagged unions can also contain record types, which normally would require a top level type definition.

>  I’m not sure how to handle records in sum types, given that accessors and friends are methods ‘bound’ to the record. The logical solution would be ‘lifing’ them to the sum, but how do you ensure that it’s called on the right variant? And what when it isn’t? Return ⊥?

> **SquidDev:** I'd suggest `Product.Sum.foo` as method names but I'm not sure about updating syntax.
> **demhydraz:** Sum.Product.foo?
> **SquidDev:** Dammn, that requires my thing of creating type definitions for each varient. Ughghghrh.


## Existentially quantified types
This is probably more fit for the type document, but are types allowed to be parametrized over constraints?

Consider
```haskell
data Box (c :: * -> Constraint) = forall a. c a => Box a
```

This could be used for boxing up all types of a certain type class together, say, in a list.
```haskell
[Box "Hello", Box 1, Box ()] :: Box Show
```

Consider that
```haskell
data Box a = Box a
```
has a different kind (`* -> *`) from
```haskell
data Box = forall a. Show a => Box a
```
which is just `*`.

## Type classes
Type classes are a way to ensure different types have a consistent interface, and to constrain polymorphic types on having an instance of a type class

> Should we have associated data families? - see https://wiki.haskell.org/GHC/Type_families#Detailed_definition_of_data_families

A constraint section on a type is given as a fat-arrow behind the type. For example, the following snippet says that “for all types for which there is an instance of `a`, there is a function `show` transforming it into a string.”

```haskell
show :: forall a. Show a => a -> String
```

The type-class mechanism poses a way to do name overloading based on types. In contrast to, say, Java interfaces, type classes allow the user to be parametric on the return type, not only the parameter types.

```haskell
class Read a where
  read :: String -> a
```

When resolving type classes the type checking algorithm will unify the current type across all instances. If more than one instance matches then an error will be created.

> Named typeclass implementations like Idris, maybe? http://docs.idris-lang.org/en/latest/tutorial/interfaces.html

> Should we have multi-parameter type classes and functional dependencies? https://wiki.haskell.org/Functional_dependencies
https://wiki.haskell.org/Multi-parameter_type_class It's harder to be unambiguous for things like `MonadState` without fundeps.

Some type classes will be auto-generated by the compiler (such as `Eq` or `Show`) if the criteria are matched (for instance all child types also implement Show). Auto-generated instances can safely be overridden or masked: there will not be a compile error if both a auto-generated and normal instance match.

## Arrow Types
Arrow types form the base of a functional type system. While _concrete_ types represent data per-se, arrow types represent relations between types, in the form of functions.

> **TODO:** Do Amulet types form a category? If so, is it a Cartesian closed category?